### æ–¹æ³•ä¸€ï¼šåŒæŒ‡é’ˆ + è®¡æ•°

æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå¦‚æœæˆ‘ä»¬å›ºå®šå­æ•°ç»„çš„å·¦ç«¯ç‚¹ï¼Œéšç€å³ç«¯ç‚¹å‘å³ç§»åŠ¨ï¼Œå­æ•°ç»„çš„æŒ‰ä½æˆ–å€¼åªä¼šå¢å¤§ï¼Œä¸ä¼šå‡å°ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆçš„æ–¹æ³•ï¼Œç»´æŠ¤ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å­æ•°ç»„ã€‚

å…·ä½“åœ°ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆ $i$ å’Œ $j$ åˆ†åˆ«è¡¨ç¤ºå­æ•°ç»„çš„å·¦å³ç«¯ç‚¹ï¼Œåˆå§‹æ—¶ä¸¤ä¸ªæŒ‡é’ˆéƒ½ä½äºæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚ç”¨ä¸€ä¸ªå˜é‡ $s$ è¡¨ç¤ºå­æ•°ç»„çš„æŒ‰ä½æˆ–å€¼ï¼Œåˆå§‹æ—¶ $s$ çš„å€¼ä¸º $0$ã€‚æˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ä¸€ä¸ªé•¿åº¦ä¸º $32$ çš„æ•°ç»„ $cnt$ï¼Œè¡¨ç¤ºå­æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æ¯ä¸€ä½çš„å‡ºç°æ¬¡æ•°ã€‚

åœ¨æ¯ä¸€æ­¥æ“ä½œä¸­ï¼Œæˆ‘ä»¬å°† $j$ å‘å³ç§»åŠ¨ä¸€ä½ï¼Œæ›´æ–° $s$ å’Œ $cnt$ã€‚å¦‚æœ $s$ çš„å€¼å¤§äºç­‰äº $k$ï¼Œæˆ‘ä»¬ä¸æ–­æ›´æ–°å­æ•°ç»„çš„æœ€å°é•¿åº¦ï¼Œå¹¶å°† $i$ å‘å³ç§»åŠ¨ä¸€ä½ï¼Œç›´åˆ° $s$ çš„å€¼å°äº $k$ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦æ›´æ–° $s$ å’Œ $cnt$ã€‚

æœ€åï¼Œæˆ‘ä»¬è¿”å›æœ€å°é•¿åº¦ï¼Œå¦‚æœä¸å­˜åœ¨æ»¡è¶³æ¡ä»¶çš„å­æ•°ç»„ï¼Œåˆ™è¿”å› $-1$ã€‚

* [sol1-Python3]

```python
class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
        n = len(nums)
        cnt = [0] * 32
        ans = n + 1
        s = i = 0
        for j, x in enumerate(nums):
            s |= x
            for h in range(32):
                if x >> h & 1:
                    cnt[h] += 1
            while s >= k and i <= j:
                ans = min(ans, j - i + 1)
                y = nums[i]
                for h in range(32):
                    if y >> h & 1:
                        cnt[h] -= 1
                        if cnt[h] == 0:
                            s ^= 1 << h
                i += 1
        return -1 if ans > n else ans
```

* [sol1-Java]

```java
class Solution {
    public int minimumSubarrayLength(int[] nums, int k) {
        int n = nums.length;
        int[] cnt = new int[32];
        int ans = n + 1;
        for (int i = 0, j = 0, s = 0; j < n; ++j) {
            s |= nums[j];
            for (int h = 0; h < 32; ++h) {
                if ((nums[j] >> h & 1) == 1) {
                    ++cnt[h];
                }
            }
            for (; s >= k && i <= j; ++i) {
                ans = Math.min(ans, j - i + 1);
                for (int h = 0; h < 32; ++h) {
                    if ((nums[i] >> h & 1) == 1) {
                        if (--cnt[h] == 0) {
                            s ^= 1 << h;
                        }
                    }
                }
            }
        }
        return ans > n ? -1 : ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int minimumSubarrayLength(vector<int>& nums, int k) {
        int n = nums.size();
        int cnt[32]{};
        int ans = n + 1;
        for (int i = 0, j = 0, s = 0; j < n; ++j) {
            s |= nums[j];
            for (int h = 0; h < 32; ++h) {
                if ((nums[j] >> h & 1) == 1) {
                    ++cnt[h];
                }
            }
            for (; s >= k && i <= j; ++i) {
                ans = min(ans, j - i + 1);
                for (int h = 0; h < 32; ++h) {
                    if ((nums[i] >> h & 1) == 1) {
                        if (--cnt[h] == 0) {
                            s ^= 1 << h;
                        }
                    }
                }
            }
        }
        return ans > n ? -1 : ans;
    }
};
```

* [sol1-Go]

```go
func minimumSubarrayLength(nums []int, k int) int {
	n := len(nums)
	cnt := [32]int{}
	ans := n + 1
	s, i := 0, 0
	for j, x := range nums {
		s |= x
		for h := 0; h < 32; h++ {
			if x>>h&1 == 1 {
				cnt[h]++
			}
		}
		for ; s >= k && i <= j; i++ {
			ans = min(ans, j-i+1)
			for h := 0; h < 32; h++ {
				if nums[i]>>h&1 == 1 {
					cnt[h]--
					if cnt[h] == 0 {
						s ^= 1 << h
					}
				}
			}
		}
	}
	if ans == n+1 {
		return -1
	}
	return ans
}
```

* [sol1-TypeScript]

```ts
function minimumSubarrayLength(nums: number[], k: number): number {
    const n = nums.length;
    let ans = n + 1;
    const cnt: number[] = new Array<number>(32).fill(0);
    for (let i = 0, j = 0, s = 0; j < n; ++j) {
        s |= nums[j];
        for (let h = 0; h < 32; ++h) {
            if (((nums[j] >> h) & 1) === 1) {
                ++cnt[h];
            }
        }
        for (; s >= k && i <= j; ++i) {
            ans = Math.min(ans, j - i + 1);
            for (let h = 0; h < 32; ++h) {
                if (((nums[i] >> h) & 1) === 1 && --cnt[h] === 0) {
                    s ^= 1 << h;
                }
            }
        }
    }
    return ans === n + 1 ? -1 : ans;
}
```

* [sol1-Rust]

```rust
impl Solution {
    pub fn minimum_subarray_length(nums: Vec<i32>, k: i32) -> i32 {
        let n = nums.len();
        let mut cnt = vec![0; 32];
        let mut ans = n as i32 + 1;
        let mut s = 0;
        let mut i = 0;

        for (j, &x) in nums.iter().enumerate() {
            s |= x;
            for h in 0..32 {
                if (x >> h) & 1 == 1 {
                    cnt[h] += 1;
                }
            }

            while s >= k && i <= j {
                ans = ans.min((j - i + 1) as i32);
                let y = nums[i];
                for h in 0..32 {
                    if (y >> h) & 1 == 1 {
                        cnt[h] -= 1;
                        if cnt[h] == 0 {
                            s ^= 1 << h;
                        }
                    }
                }
                i += 1;
            }
        }
        if ans > n as i32 { -1 } else { ans }
    }
}
```

æ—¶é—´å¤æ‚åº¦ $O(n \times \log M)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(\log M)$ï¼Œå…¶ä¸­ $n$ å’Œ $M$ åˆ†åˆ«æ˜¯æ•°ç»„çš„é•¿åº¦å’Œæ•°ç»„ä¸­å…ƒç´ çš„æœ€å¤§å€¼ã€‚

----

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
